SET SERVEROUTPUT ON;
SET VERIFY OFF
-- Ejemplo 1
DECLARE BEGIN
    dbms_output.put_line('Hola Mundo PL/SQL');
END;
/
 
-- Declaracion de variables
/*
NUMBER → números, enteros o decimales.

VARCHAR2 → texto (palabras, nombres, frases).

DATE → fechas.

BOOLEAN → verdadero/falso.

DECLARE → donde defines tus variables.

:= → le das un valor a la variable.

|| → une texto y valores para mostrarlos juntos.
*/
DECLARE
    nombre VARCHAR2(50);
    edad   NUMBER;
BEGIN
    nombre := 'Samu';
    edad := '23';
    dbms_output.put_line('Hola mi nombres es ' || nombre);
    dbms_output.put_line('tengo '
                         || edad
                         || ' años');
END;
/

-- Condicionales
/*
A veces quieres que tu programa tome decisiones según condiciones.

Usamos IF para esto: “Si esto pasa, haz esto; si no, haz otra cosa”.
*/

DECLARE
    edad NUMBER := '23';
BEGIN
    IF edad < 18 THEN
        dbms_output.put_line('Eres menor de edad');
    ELSIF
        edad >= 18
        AND edad < 30
    THEN
        dbms_output.put_line('Eres un adulto pero eres Joven');
    ELSE
        dbms_output.put_line('Eres adulto avanzado');
    END IF;
END;
/

--Bucles (loops)

--loop basico
declare
  i number := 1;
begin
  loop
    dbms_output.put_line('Numero: ' || i);
    i:= i+1;
    exit when i > 5 ;
  end loop;
end;
/

-- loop for
begin 
  for i in 1..5 loop
  dbms_output.put_line('Numero For LOOP: ' || i);
  end loop;
end;
/

-- Ejercicio Numeros Pares con Bucle 
/*
Mod = Es una funcion de Pl que devuelve el resro de una division entre dos numeros'
*/
begin
  for i in 2..60 loop
  if mod(i,2) = 0 then 
  dbms_output.put_line('Los pares son:' || i);
  end if;
  end loop;
end;
/

-- Numeros impares 

begin
  for i in 2..60 loop
  if mod(i,2) != 0 then 
  dbms_output.put_line('Los impares son:' || i);
  end if;
  end loop;
end;
/

-- Crearemos unas tablas para poder practicar lo siguiente 
CREATE TABLE Usuarios (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,  -- ID único auto incrementable
    Nombre VARCHAR2(50) NOT NULL,                             -- Nombre del usuario
    Edad NUMBER,                                              -- Edad del usuario
    Ciudad VARCHAR2(50)                                       -- Ciudad del usuario
);
INSERT INTO Usuarios (Nombre, Edad, Ciudad) VALUES ('Samu', 23, 'Dublín');
INSERT INTO Usuarios (Nombre, Edad, Ciudad) VALUES ('Marta', 23, 'Cork');
INSERT INTO Usuarios (Nombre, Edad, Ciudad) VALUES ('Ericky', 31, 'Galway');

-- Guardar los cambios
COMMIT;

select * from usuarios;

-- Ahora podemos trabajar sobre tablas en BBDD

declare 
  nombreUsuario Usuarios.Nombre%Type;
  edadUsuario Usuarios.Edad%Type;
begin
  nombreUsuario := 'Carlos';
  edadUsuario := '78';
  
  dbms_output.put_line('Nombre: ' || nombreUsuario);
  dbms_output.put_line('Edad: ' || edadUsuario);
end;
/

  
-- Tambien podremos traer datos de la tabla con select into:

declare
  nombreUsuario Usuarios.Nombre%Type;
  edadUsuario Usuarios.Edad%Type;
begin
  select Nombre, Edad
  into nombreUsuario,edadUsuario
  from Usuarios
  where Edad = 23 and rownum= 1; -- esto se pone para que solo muestre la primera fila que encuentre la otra opcion es que si hay mas coincidencias y quieres mostrar todas habria que hacer un loop
  
  dbms_output.put_line('El usuario se llama '||nombreUsuario || ' y Tiene ' ||edadusuario|| ' años');
end;
/

-- Mas practica de lo mismo
declare 
  nombreUsuario Usuarios.Nombre%TYPE;
  ciudadUsuario Usuarios.Ciudad%Type;
begin
  select Nombre, Ciudad
  into nombreUsuario, ciudadUsuario
  from Usuarios
  where rownum =1;
  
  if ciudadusuario = 'Dublín' then
   dbms_output.put_line('El usuario '||nombreusuario||' vive en  '||ciudadUsuario);
   ELSIF ciudadUsuario = 'Cork' then
   dbms_output.put_line('CORKINENSE');
  else
   dbms_output.put_line('El usuario '||nombreUsuario|| 'vive en ' ||ciudadUsuario);
   end if;
end;
/
  
-- Mas restrictivo y con un bucle por una doble condicion

BEGIN
  FOR u IN (SELECT Nombre, Ciudad FROM Usuarios) LOOP
    IF u.Nombre = 'Marta' THEN
        DBMS_OUTPUT.PUT_LINE('El usuario ' || u.Nombre || ' vive en ' || u.Ciudad);
    END IF;
  END LOOP;
END;
/

-- Solicitud de datos por consola

declare
  nombre varchar2(20);
  edad number;
begin
  nombre:='&Nombre';
  edad:=&edad;
  
  dbms_output.put_line('El usuario a ingresado su nombre que es '|| nombre || ' y su edad que es '|| edad); 
end;
/

-- usar RowType con cursores explicitos

/*
CURSOR cursor_alumnos IS SELECT ...
→ defines el cursor con la consulta que quieres recorrer.

u cursor_alumnos%ROWTYPE;
→ crea una variable u que tiene exactamente las mismas columnas y tipos que las filas que devuelve el cursor.

OPEN cursor_alumnos;
→ ejecuta la consulta y prepara el conjunto de resultados.

FETCH cursor_alumnos INTO u;
→ obtiene la siguiente fila del cursor y guarda los valores en u.

EXIT WHEN cursor_alumnos%NOTFOUND;
→ sale del bucle cuando ya no quedan filas que leer.

dbms_output.put_line(...)
→ muestra la información de cada fila.

CLOSE cursor_alumnos;
→ libera la memoria del cursor (buena práctica).
*/
declare
  cursor cursor_alumnos is
  select nombre, edad, ciudad 
  from usuarios;
  u cursor_alumnos%Rowtype;
  
begin
  open cursor_alumnos;
    loop
      fetch cursor_alumnos into u;
      exit when cursor_alumnos%NOTFOUND;
      
      dbms_output.put_line('Usuario: ' || u.nombre || '  con la edad de  ' || u.edad || '  viviendo en la Ciudad de  ' || u.ciudad);
    end loop;
  close cursor_alumnos;
end;
/

-- Manejo de Errores

declare
  edad number :=-5;
begin
  if edad < 0 then
    raise_application_error(-20001, 'Edad Invalida');
  end if;
exception
  When others then
    dbms_output.put_line('Error; ' || SQLERRM);
end;
/

 
-- LAS FUNCIONES
/*
Es importante destacar que las funciones devulven valores
y se usan para acciones repetitivas
*/

create or replace function doble_numero(p_num in number) 
return number is 
begin
  return p_num *2;
end;
/
DECLARE
    resultado NUMBER;
BEGIN
    resultado := doble_numero(10);
    dbms_output.put_line('El doble es: ' || resultado);
END;
/

-- otro ejemplo

create or replace function entre_diez(p_num in number)
return number is
begin
  return p_num/10;
end;
/
declare 
  operando number  := &Numero_a_Dividir;
  resultado number;
begin 
  resultado := entre_diez(operando);
  dbms_output.put_line('El valor  '|| operando || ' Dividido entre diez es '|| resultado);
end;
/


-- LOS PROCEDIMIENTOS
/*
Los procedimientos se usan para acciones repetitivas
Hay que tener en cuenta que no devulven valores
*/
--Ejemplo
-- a la hora de insertar nuevos registros en nuestra tabla usuarios

create or replace procedure insertar_usuarios(
  p_nombre in varchar2,
  p_edad in number,
  p_ciudad in varchar2
) as
  begin 
  if p_edad < 0 then
    raise_application_error(-2001, 'La edad no puede ser negativa');
  end if;
  
  insert into Usuarios(nombre,edad,ciudad)
  values(p_nombre,p_edad,p_ciudad);
  
  dbms_output.put_line('Usuario ' ||p_nombre || ' insertado correctamente');
  
  exception
   when others then
      dbms_output.put_line('Vigila lo que pones Bacalao : '|| SQLERRM);
  end;
/

-- Para poder usar este procedimiento deberemos insertar un nuevo usuario

begin
  insertar_usuarios('Laura',23,'Dublin');
end;
/

begin 
  insertar_usuarios('Maria',-5,'Madrid');
end;
/

SELECT * FROM usuarios;
delete from usuarios
where id=62;

-- Para practicar 
-- Crea una funcion que devuelva la edad de un usuario de la tabla usuarios

create or replace function que_edad(p_nombre varchar2) 
return number
is
  v_edad number;
begin 
  select edad
  into v_edad
  from usuarios
  where Lower(nombre) = Lower(p_nombre);
  
  return v_edad;
exception
  when no_data_found then
    dbms_output.put_line('Usuario no encontrado');
        RETURN NULL;  
    WHEN TOO_MANY_ROWS THEN
        dbms_output.put_line('Hay más de un usuario con ese nombre');
        RETURN NULL;  
end;
/

declare
  edad NUMBER;
  nombre varchar2(50) := '&UsuarioNombre';
begin
  edad := que_edad(nombre);
  if edad is not null then
    dbms_output.put_line('La edad de  ' || nombre || ' es '|| edad);
  end if;
end;
/
  

-- Package 
/*
Especificación (PACKAGE ... IS): declara lo que será público — procedimientos, funciones, tipos, constantes y variables que otros bloques podrán usar.

Cuerpo (PACKAGE BODY ... IS): contiene la implementación de lo declarado; además puede contener elementos privados (solo visibles dentro del package body).
Ventajas:
Organización: agrupa funcionalidades relacionadas.
Reutilización: centralizas lógica común.
Encapsulación: ocultas detalles internos.
Estado por sesión: las variables de paquete mantienen su valor durante la sesión del usuario (útil para caches, contadores, etc.).
Mejora en rendimiento: al compilarse, PL/SQL carga la spec y parte del body en memoria.
*/

create or replace package usuarios_pkg is
  procedure saludar(p_nombre in varchar2);
  function edad_usuario(p_nombre in varchar2) 
  return number;
end usuarios_pkg;
/

-- Los paquetes son creados para englobar varias funciones o procedimientos previamente creados

-- Triggers o Disparadores
/* 
Los disparadores son muy usados para el manejo de errores y la mantencion de la integridad de los datos antes de poder ser insertados
*/
create or replace trigger trg_usuarios_before_insert
before insert on Usuarios
for each row
begin   
  if :NEW.edad < 0 then
    raise_application_error(-20001, 'No se pueden insertar edades negativas');
  end if;
  if Upper(:New.ciudad)= 'MURCIA' then 
  raise_application_error(-20011, 'Murcia no existe');
  end if;
end;
/

INSERT INTO Usuarios (Nombre, Edad, Ciudad)
VALUES ('Samu', 23, 'Murcia');


delete from usuarios
where ciudad='Murcia';

select * from usuarios;



